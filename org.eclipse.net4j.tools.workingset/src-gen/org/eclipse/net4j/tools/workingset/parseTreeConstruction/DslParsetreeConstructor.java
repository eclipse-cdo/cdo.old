/*
* generated by Xtext
*/
package org.eclipse.net4j.tools.workingset.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.net4j.tools.workingset.services.DslGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class DslParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrExpressionParserRuleCall(this, this, 0, inst);
			case 1: return new OrExpression_Group(this, this, 1, inst);
			case 2: return new XorExpression_Group(this, this, 2, inst);
			case 3: return new AndExpression_Group(this, this, 3, inst);
			case 4: return new ComparisonExpression_Alternatives(this, this, 4, inst);
			case 5: return new PrimaryExpression_Alternatives(this, this, 5, inst);
			case 6: return new BooleanLiteral_ValueAssignment(this, this, 6, inst);
			case 7: return new NotExpression_Group(this, this, 7, inst);
			case 8: return new IsExpression_Group(this, this, 8, inst);
			case 9: return new HasExpression_Group(this, this, 9, inst);
			case 10: return new TestExpression_Group(this, this, 10, inst);
			case 11: return new ConcatExpression_Group(this, this, 11, inst);
			case 12: return new StringExpression_Alternatives(this, this, 12, inst);
			case 13: return new StringLiteral_ValueAssignment(this, this, 13, inst);
			case 14: return new PropertyAccess_PropertyAssignment(this, this, 14, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule BooleanExpression ****************
 *
 * BooleanExpression:
 * 	OrExpression;
 *
 **/

// OrExpression
protected class BooleanExpression_OrExpressionParserRuleCall extends RuleCallToken {
	
	public BooleanExpression_OrExpressionParserRuleCall(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getOrExpressionParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		if(checkForRecursion(OrExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule BooleanExpression ****************/


/************ begin Rule OrExpression ****************
 *
 * OrExpression returns BooleanExpression:
 * 	XorExpression ({OrExpression.left=current} OrOperator right=XorExpression)*;
 *
 **/

// XorExpression ({OrExpression.left=current} OrOperator right=XorExpression)*
protected class OrExpression_Group extends GroupToken {
	
	public OrExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new OrExpression_XorExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// XorExpression
protected class OrExpression_XorExpressionParserRuleCall_0 extends RuleCallToken {
	
	public OrExpression_XorExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getXorExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new XorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(XorExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({OrExpression.left=current} OrOperator right=XorExpression)*
protected class OrExpression_Group_1 extends GroupToken {
	
	public OrExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrExpression_RightAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {OrExpression.left=current}
protected class OrExpression_OrExpressionLeftAction_1_0 extends ActionToken  {

	public OrExpression_OrExpressionLeftAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new OrExpression_XorExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// OrOperator
protected class OrExpression_OrOperatorParserRuleCall_1_1 extends UnassignedTextToken {

	public OrExpression_OrOperatorParserRuleCall_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getOrOperatorParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrExpression_OrExpressionLeftAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// right=XorExpression
protected class OrExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public OrExpression_RightAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new XorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getOrExpressionAccess().getRightXorExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrExpression_OrOperatorParserRuleCall_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrExpression ****************/


/************ begin Rule XorExpression ****************
 *
 * XorExpression returns BooleanExpression:
 * 	AndExpression ({XorExpression.left=current} XorOperator right=AndExpression)*;
 *
 **/

// AndExpression ({XorExpression.left=current} XorOperator right=AndExpression)*
protected class XorExpression_Group extends GroupToken {
	
	public XorExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new XorExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new XorExpression_AndExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// AndExpression
protected class XorExpression_AndExpressionParserRuleCall_0 extends RuleCallToken {
	
	public XorExpression_AndExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getAndExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(AndExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({XorExpression.left=current} XorOperator right=AndExpression)*
protected class XorExpression_Group_1 extends GroupToken {
	
	public XorExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new XorExpression_RightAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {XorExpression.left=current}
protected class XorExpression_XorExpressionLeftAction_1_0 extends ActionToken  {

	public XorExpression_XorExpressionLeftAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new XorExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new XorExpression_AndExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// XorOperator
protected class XorExpression_XorOperatorParserRuleCall_1_1 extends UnassignedTextToken {

	public XorExpression_XorOperatorParserRuleCall_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getXorOperatorParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new XorExpression_XorExpressionLeftAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// right=AndExpression
protected class XorExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public XorExpression_RightAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getXorExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getXorExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new XorExpression_XorOperatorParserRuleCall_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule XorExpression ****************/


/************ begin Rule AndExpression ****************
 *
 * AndExpression returns BooleanExpression:
 * 	ComparisonExpression ({AndExpression.left=current} AndOperator right=ComparisonExpression)*;
 *
 **/

// ComparisonExpression ({AndExpression.left=current} AndOperator right=ComparisonExpression)*
protected class AndExpression_Group extends GroupToken {
	
	public AndExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AndExpression_ComparisonExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ComparisonExpression
protected class AndExpression_ComparisonExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndExpression_ComparisonExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getComparisonExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(ComparisonExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({AndExpression.left=current} AndOperator right=ComparisonExpression)*
protected class AndExpression_Group_1 extends GroupToken {
	
	public AndExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndExpression_RightAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {AndExpression.left=current}
protected class AndExpression_AndExpressionLeftAction_1_0 extends ActionToken  {

	public AndExpression_AndExpressionLeftAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new AndExpression_ComparisonExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// AndOperator
protected class AndExpression_AndOperatorParserRuleCall_1_1 extends UnassignedTextToken {

	public AndExpression_AndOperatorParserRuleCall_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getAndOperatorParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AndExpression_AndExpressionLeftAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// right=ComparisonExpression
protected class AndExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public AndExpression_RightAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getComparisonExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getAndExpressionAccess().getRightComparisonExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndExpression_AndOperatorParserRuleCall_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndExpression ****************/


/************ begin Rule ComparisonExpression ****************
 *
 * ComparisonExpression returns BooleanExpression:
 * 	PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)* |
 * 	ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+;
 *
 **/

// PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)* |
// ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+
protected class ComparisonExpression_Alternatives extends AlternativesToken {

	public ComparisonExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Group_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ComparisonExpression_Group_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)*
protected class ComparisonExpression_Group_0 extends GroupToken {
	
	public ComparisonExpression_Group_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Group_0_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ComparisonExpression_PrimaryExpressionParserRuleCall_0_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// PrimaryExpression
protected class ComparisonExpression_PrimaryExpressionParserRuleCall_0_0 extends RuleCallToken {
	
	public ComparisonExpression_PrimaryExpressionParserRuleCall_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getPrimaryExpressionParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(PrimaryExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)*
protected class ComparisonExpression_Group_0_1 extends GroupToken {
	
	public ComparisonExpression_Group_0_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_RightAssignment_0_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {BooleanComparison.left=current}
protected class ComparisonExpression_BooleanComparisonLeftAction_0_1_0 extends ActionToken  {

	public ComparisonExpression_BooleanComparisonLeftAction_0_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Group_0_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ComparisonExpression_PrimaryExpressionParserRuleCall_0_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=ComparisonOperator
protected class ComparisonExpression_OperatorAssignment_0_1_1 extends AssignmentToken  {
	
	public ComparisonExpression_OperatorAssignment_0_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getOperatorAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_BooleanComparisonLeftAction_0_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getComparisonExpressionAccess().getOperatorComparisonOperatorEnumRuleCall_0_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getComparisonExpressionAccess().getOperatorComparisonOperatorEnumRuleCall_0_1_1_0();
			return obj;
		}
		return null;
	}

}

// right=PrimaryExpression
protected class ComparisonExpression_RightAssignment_0_1_2 extends AssignmentToken  {
	
	public ComparisonExpression_RightAssignment_0_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getRightAssignment_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getComparisonExpressionAccess().getRightPrimaryExpressionParserRuleCall_0_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ComparisonExpression_OperatorAssignment_0_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+
protected class ComparisonExpression_Group_1 extends GroupToken {
	
	public ComparisonExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Group_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ConcatExpression
protected class ComparisonExpression_ConcatExpressionParserRuleCall_1_0 extends RuleCallToken {
	
	public ComparisonExpression_ConcatExpressionParserRuleCall_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getConcatExpressionParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConcatExpressionAccess().getConcatExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPropertyAccessRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(ConcatExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+
protected class ComparisonExpression_Group_1_1 extends GroupToken {
	
	public ComparisonExpression_Group_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_RightAssignment_1_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// {StringComparison.left=current}
protected class ComparisonExpression_StringComparisonLeftAction_1_1_0 extends ActionToken  {

	public ComparisonExpression_StringComparisonLeftAction_1_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Group_1_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ComparisonExpression_ConcatExpressionParserRuleCall_1_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// operator=StringOperator
protected class ComparisonExpression_OperatorAssignment_1_1_1 extends AssignmentToken  {
	
	public ComparisonExpression_OperatorAssignment_1_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getOperatorAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ComparisonExpression_StringComparisonLeftAction_1_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("operator",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("operator");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getComparisonExpressionAccess().getOperatorStringOperatorEnumRuleCall_1_1_1_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getComparisonExpressionAccess().getOperatorStringOperatorEnumRuleCall_1_1_1_0();
			return obj;
		}
		return null;
	}

}

// right=ConcatExpression
protected class ComparisonExpression_RightAssignment_1_1_2 extends AssignmentToken  {
	
	public ComparisonExpression_RightAssignment_1_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getRightAssignment_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getComparisonExpressionAccess().getRightConcatExpressionParserRuleCall_1_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ComparisonExpression_OperatorAssignment_1_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule ComparisonExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns BooleanExpression:
 * 	BooleanLiteral | NotExpression | IsExpression | HasExpression | TestExpression | "(" OrExpression ")";
 *
 **/

// BooleanLiteral | NotExpression | IsExpression | HasExpression | TestExpression | "(" OrExpression ")"
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanLiteralParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new PrimaryExpression_NotExpressionParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new PrimaryExpression_IsExpressionParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new PrimaryExpression_HasExpressionParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			case 4: return new PrimaryExpression_TestExpressionParserRuleCall_4(lastRuleCallOrigin, this, 4, inst);
			case 5: return new PrimaryExpression_Group_5(lastRuleCallOrigin, this, 5, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getBooleanComparisonLeftAction_0_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getComparisonExpressionAccess().getStringComparisonLeftAction_1_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getXorExpressionAccess().getXorExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// BooleanLiteral
protected class PrimaryExpression_BooleanLiteralParserRuleCall_0 extends RuleCallToken {
	
	public PrimaryExpression_BooleanLiteralParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBooleanLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new BooleanLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(BooleanLiteral_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// NotExpression
protected class PrimaryExpression_NotExpressionParserRuleCall_1 extends RuleCallToken {
	
	public PrimaryExpression_NotExpressionParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getNotExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(NotExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// IsExpression
protected class PrimaryExpression_IsExpressionParserRuleCall_2 extends RuleCallToken {
	
	public PrimaryExpression_IsExpressionParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIsExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IsExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(IsExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// HasExpression
protected class PrimaryExpression_HasExpressionParserRuleCall_3 extends RuleCallToken {
	
	public PrimaryExpression_HasExpressionParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getHasExpressionParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HasExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(HasExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// TestExpression
protected class PrimaryExpression_TestExpressionParserRuleCall_4 extends RuleCallToken {
	
	public PrimaryExpression_TestExpressionParserRuleCall_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getTestExpressionParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(TestExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// "(" OrExpression ")"
protected class PrimaryExpression_Group_5 extends GroupToken {
	
	public PrimaryExpression_Group_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_RightParenthesisKeyword_5_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class PrimaryExpression_LeftParenthesisKeyword_5_0 extends KeywordToken  {
	
	public PrimaryExpression_LeftParenthesisKeyword_5_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLeftParenthesisKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// OrExpression
protected class PrimaryExpression_OrExpressionParserRuleCall_5_1 extends RuleCallToken {
	
	public PrimaryExpression_OrExpressionParserRuleCall_5_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getOrExpressionParserRuleCall_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(OrExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_LeftParenthesisKeyword_5_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class PrimaryExpression_RightParenthesisKeyword_5_2 extends KeywordToken  {
	
	public PrimaryExpression_RightParenthesisKeyword_5_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getRightParenthesisKeyword_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_OrExpressionParserRuleCall_5_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule PrimaryExpression ****************/


/************ begin Rule BooleanLiteral ****************
 *
 * BooleanLiteral:
 * 	value=BOOLEAN;
 *
 **/

// value=BOOLEAN
protected class BooleanLiteral_ValueAssignment extends AssignmentToken  {
	
	public BooleanLiteral_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getBooleanLiteralRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getBooleanLiteralAccess().getValueBOOLEANTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getBooleanLiteralAccess().getValueBOOLEANTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanLiteral ****************/


/************ begin Rule NotExpression ****************
 *
 * NotExpression returns BooleanExpression:
 * 	{NotExpression} NotOperator right=PrimaryExpression;
 *
 **/

// {NotExpression} NotOperator right=PrimaryExpression
protected class NotExpression_Group extends GroupToken {
	
	public NotExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNotExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotExpression_RightAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNotExpressionAccess().getNotExpressionAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NotExpression}
protected class NotExpression_NotExpressionAction_0 extends ActionToken  {

	public NotExpression_NotExpressionAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNotExpressionAccess().getNotExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// NotOperator
protected class NotExpression_NotOperatorParserRuleCall_1 extends UnassignedTextToken {

	public NotExpression_NotOperatorParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotExpressionAccess().getNotOperatorParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NotExpression_NotExpressionAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// right=PrimaryExpression
protected class NotExpression_RightAssignment_2 extends AssignmentToken  {
	
	public NotExpression_RightAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNotExpressionAccess().getRightAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNotExpressionAccess().getRightPrimaryExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NotExpression_NotOperatorParserRuleCall_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NotExpression ****************/


/************ begin Rule IsExpression ****************
 *
 * IsExpression returns BooleanExpression:
 * 	{IsExpression} "is" type=Type;
 *
 **/

// {IsExpression} "is" type=Type
protected class IsExpression_Group extends GroupToken {
	
	public IsExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIsExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IsExpression_TypeAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getIsExpressionAccess().getIsExpressionAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {IsExpression}
protected class IsExpression_IsExpressionAction_0 extends ActionToken  {

	public IsExpression_IsExpressionAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getIsExpressionAccess().getIsExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "is"
protected class IsExpression_IsKeyword_1 extends KeywordToken  {
	
	public IsExpression_IsKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIsExpressionAccess().getIsKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IsExpression_IsExpressionAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// type=Type
protected class IsExpression_TypeAssignment_2 extends AssignmentToken  {
	
	public IsExpression_TypeAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIsExpressionAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new IsExpression_IsKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("type",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("type");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getIsExpressionAccess().getTypeTypeEnumRuleCall_2_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getIsExpressionAccess().getTypeTypeEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule IsExpression ****************/


/************ begin Rule HasExpression ****************
 *
 * HasExpression returns BooleanExpression:
 * 	{HasExpression} "has" kind=Kind what=ConcatExpression;
 *
 **/

// {HasExpression} "has" kind=Kind what=ConcatExpression
protected class HasExpression_Group extends GroupToken {
	
	public HasExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHasExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HasExpression_WhatAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHasExpressionAccess().getHasExpressionAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {HasExpression}
protected class HasExpression_HasExpressionAction_0 extends ActionToken  {

	public HasExpression_HasExpressionAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getHasExpressionAccess().getHasExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "has"
protected class HasExpression_HasKeyword_1 extends KeywordToken  {
	
	public HasExpression_HasKeyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getHasExpressionAccess().getHasKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HasExpression_HasExpressionAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// kind=Kind
protected class HasExpression_KindAssignment_2 extends AssignmentToken  {
	
	public HasExpression_KindAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHasExpressionAccess().getKindAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new HasExpression_HasKeyword_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("kind",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("kind");
		if(enumLitSerializer.isValid(obj.getEObject(), grammarAccess.getHasExpressionAccess().getKindKindEnumRuleCall_2_0(), value, null)) { 
			type = AssignmentType.ENUM_RULE_CALL;
			element = grammarAccess.getHasExpressionAccess().getKindKindEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// what=ConcatExpression
protected class HasExpression_WhatAssignment_3 extends AssignmentToken  {
	
	public HasExpression_WhatAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHasExpressionAccess().getWhatAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("what",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("what");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getHasExpressionAccess().getWhatConcatExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new HasExpression_KindAssignment_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule HasExpression ****************/


/************ begin Rule TestExpression ****************
 *
 * TestExpression returns BooleanExpression:
 * 	{TestExpression} property+=ID ("." property+=ID)* "(" args+=ConcatExpression ("," args+=ConcatExpression)* ")" "is"
 * 	expected=ConcatExpression;
 *
 **/

// {TestExpression} property+=ID ("." property+=ID)* "(" args+=ConcatExpression ("," args+=ConcatExpression)* ")" "is"
// expected=ConcatExpression
protected class TestExpression_Group extends GroupToken {
	
	public TestExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_ExpectedAssignment_8(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getTestExpressionAccess().getTestExpressionAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {TestExpression}
protected class TestExpression_TestExpressionAction_0 extends ActionToken  {

	public TestExpression_TestExpressionAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getTestExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// property+=ID
protected class TestExpression_PropertyAssignment_1 extends AssignmentToken  {
	
	public TestExpression_PropertyAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getPropertyAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_TestExpressionAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("property",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("property");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getTestExpressionAccess().getPropertyIDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getTestExpressionAccess().getPropertyIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("." property+=ID)*
protected class TestExpression_Group_2 extends GroupToken {
	
	public TestExpression_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_PropertyAssignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "."
protected class TestExpression_FullStopKeyword_2_0 extends KeywordToken  {
	
	public TestExpression_FullStopKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getFullStopKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new TestExpression_PropertyAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// property+=ID
protected class TestExpression_PropertyAssignment_2_1 extends AssignmentToken  {
	
	public TestExpression_PropertyAssignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getPropertyAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_FullStopKeyword_2_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("property",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("property");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getTestExpressionAccess().getPropertyIDTerminalRuleCall_2_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getTestExpressionAccess().getPropertyIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}


// "("
protected class TestExpression_LeftParenthesisKeyword_3 extends KeywordToken  {
	
	public TestExpression_LeftParenthesisKeyword_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getLeftParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new TestExpression_PropertyAssignment_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// args+=ConcatExpression
protected class TestExpression_ArgsAssignment_4 extends AssignmentToken  {
	
	public TestExpression_ArgsAssignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getArgsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("args",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTestExpressionAccess().getArgsConcatExpressionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TestExpression_LeftParenthesisKeyword_3(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," args+=ConcatExpression)*
protected class TestExpression_Group_5 extends GroupToken {
	
	public TestExpression_Group_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_ArgsAssignment_5_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// ","
protected class TestExpression_CommaKeyword_5_0 extends KeywordToken  {
	
	public TestExpression_CommaKeyword_5_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getCommaKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_Group_5(lastRuleCallOrigin, this, 0, inst);
			case 1: return new TestExpression_ArgsAssignment_4(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// args+=ConcatExpression
protected class TestExpression_ArgsAssignment_5_1 extends AssignmentToken  {
	
	public TestExpression_ArgsAssignment_5_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getArgsAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("args",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTestExpressionAccess().getArgsConcatExpressionParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TestExpression_CommaKeyword_5_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class TestExpression_RightParenthesisKeyword_6 extends KeywordToken  {
	
	public TestExpression_RightParenthesisKeyword_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getRightParenthesisKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_Group_5(lastRuleCallOrigin, this, 0, inst);
			case 1: return new TestExpression_ArgsAssignment_4(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// "is"
protected class TestExpression_IsKeyword_7 extends KeywordToken  {
	
	public TestExpression_IsKeyword_7(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getIsKeyword_7();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new TestExpression_RightParenthesisKeyword_6(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// expected=ConcatExpression
protected class TestExpression_ExpectedAssignment_8 extends AssignmentToken  {
	
	public TestExpression_ExpectedAssignment_8(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTestExpressionAccess().getExpectedAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("expected",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("expected");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getTestExpressionAccess().getExpectedConcatExpressionParserRuleCall_8_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TestExpression_IsKeyword_7(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TestExpression ****************/


/************ begin Rule ConcatExpression ****************
 *
 * ConcatExpression returns StringExpression:
 * 	StringExpression ({ConcatExpression.left=current} "+" right=StringExpression)*;
 *
 **/

// StringExpression ({ConcatExpression.left=current} "+" right=StringExpression)*
protected class ConcatExpression_Group extends GroupToken {
	
	public ConcatExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcatExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ConcatExpression_StringExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConcatExpressionAccess().getConcatExpressionLeftAction_1_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getPropertyAccessRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// StringExpression
protected class ConcatExpression_StringExpressionParserRuleCall_0 extends RuleCallToken {
	
	public ConcatExpression_StringExpressionParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getConcatExpressionAccess().getStringExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPropertyAccessRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(StringExpression_Alternatives.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// ({ConcatExpression.left=current} "+" right=StringExpression)*
protected class ConcatExpression_Group_1 extends GroupToken {
	
	public ConcatExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcatExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_RightAssignment_1_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getConcatExpressionAccess().getConcatExpressionLeftAction_1_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {ConcatExpression.left=current}
protected class ConcatExpression_ConcatExpressionLeftAction_1_0 extends ActionToken  {

	public ConcatExpression_ConcatExpressionLeftAction_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getConcatExpressionAccess().getConcatExpressionLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new ConcatExpression_StringExpressionParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "+"
protected class ConcatExpression_PlusSignKeyword_1_1 extends KeywordToken  {
	
	public ConcatExpression_PlusSignKeyword_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcatExpressionAccess().getPlusSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new ConcatExpression_ConcatExpressionLeftAction_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// right=StringExpression
protected class ConcatExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public ConcatExpression_RightAssignment_1_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcatExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("right",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStringExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getConcatExpressionAccess().getRightStringExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConcatExpression_PlusSignKeyword_1_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ConcatExpression ****************/


/************ begin Rule StringExpression ****************
 *
 * StringExpression:
 * 	StringLiteral | PropertyAccess;
 *
 **/

// StringLiteral | PropertyAccess
protected class StringExpression_Alternatives extends AlternativesToken {

	public StringExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStringExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringExpression_StringLiteralParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new StringExpression_PropertyAccessParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPropertyAccessRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// StringLiteral
protected class StringExpression_StringLiteralParserRuleCall_0 extends RuleCallToken {
	
	public StringExpression_StringLiteralParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStringExpressionAccess().getStringLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new StringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		if(checkForRecursion(StringLiteral_ValueAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// PropertyAccess
protected class StringExpression_PropertyAccessParserRuleCall_1 extends RuleCallToken {
	
	public StringExpression_PropertyAccessParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStringExpressionAccess().getPropertyAccessParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PropertyAccess_PropertyAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPropertyAccessRule().getType().getClassifier())
			return null;
		if(checkForRecursion(PropertyAccess_PropertyAssignment.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule StringExpression ****************/


/************ begin Rule StringLiteral ****************
 *
 * StringLiteral:
 * 	value=STRING;
 *
 **/

// value=STRING
protected class StringLiteral_ValueAssignment extends AssignmentToken  {
	
	public StringLiteral_ValueAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getStringLiteralRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("value",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringLiteral ****************/


/************ begin Rule PropertyAccess ****************
 *
 * PropertyAccess:
 * 	property=ID;
 *
 **/

// property=ID
protected class PropertyAccess_PropertyAssignment extends AssignmentToken  {
	
	public PropertyAccess_PropertyAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyAccessAccess().getPropertyAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPropertyAccessRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("property",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("property");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getPropertyAccessAccess().getPropertyIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getPropertyAccessAccess().getPropertyIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule PropertyAccess ****************/





}
