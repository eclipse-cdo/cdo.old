/*
* generated by Xtext
*/

package org.eclipse.net4j.tools.workingset.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class DslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanExpression");
		private final RuleCall cOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BooleanExpression:
		//	OrExpression;
		public ParserRule getRule() { return rule; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall() { return cOrExpressionParserRuleCall; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cOrOperatorParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//OrExpression returns BooleanExpression:
		//	XorExpression ({OrExpression.left=current} OrOperator right=XorExpression)*;
		public ParserRule getRule() { return rule; }

		//XorExpression ({OrExpression.left=current} OrOperator right=XorExpression)*
		public Group getGroup() { return cGroup; }

		//XorExpression
		public RuleCall getXorExpressionParserRuleCall_0() { return cXorExpressionParserRuleCall_0; }

		//({OrExpression.left=current} OrOperator right=XorExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrExpression.left=current}
		public Action getOrExpressionLeftAction_1_0() { return cOrExpressionLeftAction_1_0; }

		//OrOperator
		public RuleCall getOrOperatorParserRuleCall_1_1() { return cOrOperatorParserRuleCall_1_1; }

		//right=XorExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//XorExpression
		public RuleCall getRightXorExpressionParserRuleCall_1_2_0() { return cRightXorExpressionParserRuleCall_1_2_0; }
	}

	public class XorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cXorOperatorParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//XorExpression returns BooleanExpression:
		//	AndExpression ({XorExpression.left=current} XorOperator right=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({XorExpression.left=current} XorOperator right=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({XorExpression.left=current} XorOperator right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{XorExpression.left=current}
		public Action getXorExpressionLeftAction_1_0() { return cXorExpressionLeftAction_1_0; }

		//XorOperator
		public RuleCall getXorOperatorParserRuleCall_1_1() { return cXorOperatorParserRuleCall_1_1; }

		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cAndOperatorParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression returns BooleanExpression:
		//	ComparisonExpression ({AndExpression.left=current} AndOperator right=ComparisonExpression)*;
		public ParserRule getRule() { return rule; }

		//ComparisonExpression ({AndExpression.left=current} AndOperator right=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({AndExpression.left=current} AndOperator right=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0() { return cAndExpressionLeftAction_1_0; }

		//AndOperator
		public RuleCall getAndOperatorParserRuleCall_1_1() { return cAndOperatorParserRuleCall_1_1; }

		//right=ComparisonExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightComparisonExpressionParserRuleCall_1_2_0() { return cRightComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cPrimaryExpressionParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Action cBooleanComparisonLeftAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cOperatorComparisonOperatorEnumRuleCall_0_1_1_0 = (RuleCall)cOperatorAssignment_0_1_1.eContents().get(0);
		private final Assignment cRightAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_0_1_2_0 = (RuleCall)cRightAssignment_0_1_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cConcatExpressionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Action cStringComparisonLeftAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cOperatorStringOperatorEnumRuleCall_1_1_1_0 = (RuleCall)cOperatorAssignment_1_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightConcatExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		
		//ComparisonExpression returns BooleanExpression:
		//	PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)* |
		//	ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)* |
		//ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)*
		public Group getGroup_0() { return cGroup_0; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0_0() { return cPrimaryExpressionParserRuleCall_0_0; }

		//({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{BooleanComparison.left=current}
		public Action getBooleanComparisonLeftAction_0_1_0() { return cBooleanComparisonLeftAction_0_1_0; }

		//operator=ComparisonOperator
		public Assignment getOperatorAssignment_0_1_1() { return cOperatorAssignment_0_1_1; }

		//ComparisonOperator
		public RuleCall getOperatorComparisonOperatorEnumRuleCall_0_1_1_0() { return cOperatorComparisonOperatorEnumRuleCall_0_1_1_0; }

		//right=PrimaryExpression
		public Assignment getRightAssignment_0_1_2() { return cRightAssignment_0_1_2; }

		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_0_1_2_0() { return cRightPrimaryExpressionParserRuleCall_0_1_2_0; }

		//ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+
		public Group getGroup_1() { return cGroup_1; }

		//ConcatExpression
		public RuleCall getConcatExpressionParserRuleCall_1_0() { return cConcatExpressionParserRuleCall_1_0; }

		//({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{StringComparison.left=current}
		public Action getStringComparisonLeftAction_1_1_0() { return cStringComparisonLeftAction_1_1_0; }

		//operator=StringOperator
		public Assignment getOperatorAssignment_1_1_1() { return cOperatorAssignment_1_1_1; }

		//StringOperator
		public RuleCall getOperatorStringOperatorEnumRuleCall_1_1_1_0() { return cOperatorStringOperatorEnumRuleCall_1_1_1_0; }

		//right=ConcatExpression
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }

		//ConcatExpression
		public RuleCall getRightConcatExpressionParserRuleCall_1_1_2_0() { return cRightConcatExpressionParserRuleCall_1_1_2_0; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNotExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIsExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cHasExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTestExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cOrExpressionParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		
		//PrimaryExpression returns BooleanExpression:
		//	BooleanLiteral | NotExpression | IsExpression | HasExpression | TestExpression | "(" OrExpression ")";
		public ParserRule getRule() { return rule; }

		//BooleanLiteral | NotExpression | IsExpression | HasExpression | TestExpression | "(" OrExpression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }

		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_1() { return cNotExpressionParserRuleCall_1; }

		//IsExpression
		public RuleCall getIsExpressionParserRuleCall_2() { return cIsExpressionParserRuleCall_2; }

		//HasExpression
		public RuleCall getHasExpressionParserRuleCall_3() { return cHasExpressionParserRuleCall_3; }

		//TestExpression
		public RuleCall getTestExpressionParserRuleCall_4() { return cTestExpressionParserRuleCall_4; }

		//"(" OrExpression ")"
		public Group getGroup_5() { return cGroup_5; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_5_1() { return cOrExpressionParserRuleCall_5_1; }

		//")"
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanLiteral:
		//	value=BOOLEAN;
		public ParserRule getRule() { return rule; }

		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}

	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cNotOperatorParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//NotExpression returns BooleanExpression:
		//	{NotExpression} NotOperator right=PrimaryExpression;
		public ParserRule getRule() { return rule; }

		//{NotExpression} NotOperator right=PrimaryExpression
		public Group getGroup() { return cGroup; }

		//{NotExpression}
		public Action getNotExpressionAction_0() { return cNotExpressionAction_0; }

		//NotOperator
		public RuleCall getNotOperatorParserRuleCall_1() { return cNotOperatorParserRuleCall_1; }

		//right=PrimaryExpression
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_2_0() { return cRightPrimaryExpressionParserRuleCall_2_0; }
	}

	public class IsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IsExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIsExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeEnumRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//IsExpression returns BooleanExpression:
		//	{IsExpression} "is" type=Type;
		public ParserRule getRule() { return rule; }

		//{IsExpression} "is" type=Type
		public Group getGroup() { return cGroup; }

		//{IsExpression}
		public Action getIsExpressionAction_0() { return cIsExpressionAction_0; }

		//"is"
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }

		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Type
		public RuleCall getTypeTypeEnumRuleCall_2_0() { return cTypeTypeEnumRuleCall_2_0; }
	}

	public class HasExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HasExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHasExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHasKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cKindAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cKindKindEnumRuleCall_2_0 = (RuleCall)cKindAssignment_2.eContents().get(0);
		private final Assignment cWhatAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cWhatConcatExpressionParserRuleCall_3_0 = (RuleCall)cWhatAssignment_3.eContents().get(0);
		
		//HasExpression returns BooleanExpression:
		//	{HasExpression} "has" kind=Kind what=ConcatExpression;
		public ParserRule getRule() { return rule; }

		//{HasExpression} "has" kind=Kind what=ConcatExpression
		public Group getGroup() { return cGroup; }

		//{HasExpression}
		public Action getHasExpressionAction_0() { return cHasExpressionAction_0; }

		//"has"
		public Keyword getHasKeyword_1() { return cHasKeyword_1; }

		//kind=Kind
		public Assignment getKindAssignment_2() { return cKindAssignment_2; }

		//Kind
		public RuleCall getKindKindEnumRuleCall_2_0() { return cKindKindEnumRuleCall_2_0; }

		//what=ConcatExpression
		public Assignment getWhatAssignment_3() { return cWhatAssignment_3; }

		//ConcatExpression
		public RuleCall getWhatConcatExpressionParserRuleCall_3_0() { return cWhatConcatExpressionParserRuleCall_3_0; }
	}

	public class TestExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TestExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTestExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPropertyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPropertyIDTerminalRuleCall_1_0 = (RuleCall)cPropertyAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPropertyAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPropertyIDTerminalRuleCall_2_1_0 = (RuleCall)cPropertyAssignment_2_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cArgsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cArgsConcatExpressionParserRuleCall_4_0 = (RuleCall)cArgsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cArgsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cArgsConcatExpressionParserRuleCall_5_1_0 = (RuleCall)cArgsAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cIsKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cExpectedAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cExpectedConcatExpressionParserRuleCall_8_0 = (RuleCall)cExpectedAssignment_8.eContents().get(0);
		
		//TestExpression returns BooleanExpression:
		//	{TestExpression} property+=ID ("." property+=ID)* "(" args+=ConcatExpression ("," args+=ConcatExpression)* ")" "is"
		//	expected=ConcatExpression;
		public ParserRule getRule() { return rule; }

		//{TestExpression} property+=ID ("." property+=ID)* "(" args+=ConcatExpression ("," args+=ConcatExpression)* ")" "is"
		//expected=ConcatExpression
		public Group getGroup() { return cGroup; }

		//{TestExpression}
		public Action getTestExpressionAction_0() { return cTestExpressionAction_0; }

		//property+=ID
		public Assignment getPropertyAssignment_1() { return cPropertyAssignment_1; }

		//ID
		public RuleCall getPropertyIDTerminalRuleCall_1_0() { return cPropertyIDTerminalRuleCall_1_0; }

		//("." property+=ID)*
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//property+=ID
		public Assignment getPropertyAssignment_2_1() { return cPropertyAssignment_2_1; }

		//ID
		public RuleCall getPropertyIDTerminalRuleCall_2_1_0() { return cPropertyIDTerminalRuleCall_2_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//args+=ConcatExpression
		public Assignment getArgsAssignment_4() { return cArgsAssignment_4; }

		//ConcatExpression
		public RuleCall getArgsConcatExpressionParserRuleCall_4_0() { return cArgsConcatExpressionParserRuleCall_4_0; }

		//("," args+=ConcatExpression)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//args+=ConcatExpression
		public Assignment getArgsAssignment_5_1() { return cArgsAssignment_5_1; }

		//ConcatExpression
		public RuleCall getArgsConcatExpressionParserRuleCall_5_1_0() { return cArgsConcatExpressionParserRuleCall_5_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }

		//"is"
		public Keyword getIsKeyword_7() { return cIsKeyword_7; }

		//expected=ConcatExpression
		public Assignment getExpectedAssignment_8() { return cExpectedAssignment_8; }

		//ConcatExpression
		public RuleCall getExpectedConcatExpressionParserRuleCall_8_0() { return cExpectedConcatExpressionParserRuleCall_8_0; }
	}

	public class ConcatExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcatExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cStringExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConcatExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightStringExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ConcatExpression returns StringExpression:
		//	StringExpression ({ConcatExpression.left=current} "+" right=StringExpression)*;
		public ParserRule getRule() { return rule; }

		//StringExpression ({ConcatExpression.left=current} "+" right=StringExpression)*
		public Group getGroup() { return cGroup; }

		//StringExpression
		public RuleCall getStringExpressionParserRuleCall_0() { return cStringExpressionParserRuleCall_0; }

		//({ConcatExpression.left=current} "+" right=StringExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ConcatExpression.left=current}
		public Action getConcatExpressionLeftAction_1_0() { return cConcatExpressionLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=StringExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//StringExpression
		public RuleCall getRightStringExpressionParserRuleCall_1_2_0() { return cRightStringExpressionParserRuleCall_1_2_0; }
	}

	public class StringExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStringLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPropertyAccessParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//StringExpression:
		//	StringLiteral | PropertyAccess;
		public ParserRule getRule() { return rule; }

		//StringLiteral | PropertyAccess
		public Alternatives getAlternatives() { return cAlternatives; }

		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_0() { return cStringLiteralParserRuleCall_0; }

		//PropertyAccess
		public RuleCall getPropertyAccessParserRuleCall_1() { return cPropertyAccessParserRuleCall_1; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class PropertyAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyAccess");
		private final Assignment cPropertyAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPropertyIDTerminalRuleCall_0 = (RuleCall)cPropertyAssignment.eContents().get(0);
		
		//PropertyAccess:
		//	property=ID;
		public ParserRule getRule() { return rule; }

		//property=ID
		public Assignment getPropertyAssignment() { return cPropertyAssignment; }

		//ID
		public RuleCall getPropertyIDTerminalRuleCall_0() { return cPropertyIDTerminalRuleCall_0; }
	}

	public class OrOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOrKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OrOperator returns ecore::EString:
		//	"|" | "||" | "or";
		public ParserRule getRule() { return rule; }

		//"|" | "||" | "or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"|"
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1() { return cVerticalLineVerticalLineKeyword_1; }

		//"or"
		public Keyword getOrKeyword_2() { return cOrKeyword_2; }
	}

	public class XorOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "XorOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cXorKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//XorOperator returns ecore::EString:
		//	"^" | "xor";
		public ParserRule getRule() { return rule; }

		//"^" | "xor"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"^"
		public Keyword getCircumflexAccentKeyword_0() { return cCircumflexAccentKeyword_0; }

		//"xor"
		public Keyword getXorKeyword_1() { return cXorKeyword_1; }
	}

	public class AndOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAmpersandKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAndKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AndOperator returns ecore::EString:
		//	"&" | "&&" | "and";
		public ParserRule getRule() { return rule; }

		//"&" | "&&" | "and"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"&"
		public Keyword getAmpersandKeyword_0() { return cAmpersandKeyword_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1() { return cAmpersandAmpersandKeyword_1; }

		//"and"
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }
	}

	public class NotOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//NotOperator returns ecore::EString:
		//	"!" | "not";
		public ParserRule getRule() { return rule; }

		//"!" | "not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
	}
	
	
	public class ComparisonOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEQ2EnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEQ2EqualsSignEqualsSignKeyword_1_0 = (Keyword)cEQ2EnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_2_0 = (Keyword)cNEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNE2EnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNE2LessThanSignGreaterThanSignKeyword_3_0 = (Keyword)cNE2EnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGTGreaterThanSignKeyword_4_0 = (Keyword)cGTEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGEEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cLTLessThanSignKeyword_6_0 = (Keyword)cLTEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cLELessThanSignEqualsSignKeyword_7_0 = (Keyword)cLEEnumLiteralDeclaration_7.eContents().get(0);
		
		//enum ComparisonOperator:
		//	EQ="=" | EQ2="==" | NE="!=" | NE2="<>" | GT=">" | GE=">=" | LT="<" | LE="<=";
		public EnumRule getRule() { return rule; }

		//EQ="=" | EQ2="==" | NE="!=" | NE2="<>" | GT=">" | GE=">=" | LT="<" | LE="<="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQ="="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }

		//EQ2="=="
		public EnumLiteralDeclaration getEQ2EnumLiteralDeclaration_1() { return cEQ2EnumLiteralDeclaration_1; }

		//"=="
		public Keyword getEQ2EqualsSignEqualsSignKeyword_1_0() { return cEQ2EqualsSignEqualsSignKeyword_1_0; }

		//NE="!="
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_2() { return cNEEnumLiteralDeclaration_2; }

		//"!="
		public Keyword getNEExclamationMarkEqualsSignKeyword_2_0() { return cNEExclamationMarkEqualsSignKeyword_2_0; }

		//NE2="<>"
		public EnumLiteralDeclaration getNE2EnumLiteralDeclaration_3() { return cNE2EnumLiteralDeclaration_3; }

		//"<>"
		public Keyword getNE2LessThanSignGreaterThanSignKeyword_3_0() { return cNE2LessThanSignGreaterThanSignKeyword_3_0; }

		//GT=">"
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_4() { return cGTEnumLiteralDeclaration_4; }

		//">"
		public Keyword getGTGreaterThanSignKeyword_4_0() { return cGTGreaterThanSignKeyword_4_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_5() { return cGEEnumLiteralDeclaration_5; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_5_0() { return cGEGreaterThanSignEqualsSignKeyword_5_0; }

		//LT="<"
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_6() { return cLTEnumLiteralDeclaration_6; }

		//"<"
		public Keyword getLTLessThanSignKeyword_6_0() { return cLTLessThanSignKeyword_6_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_7() { return cLEEnumLiteralDeclaration_7; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_7_0() { return cLELessThanSignEqualsSignKeyword_7_0; }
	}

	public class StringOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "StringOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEQ2EnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEQ2EqualsSignEqualsSignKeyword_1_0 = (Keyword)cEQ2EnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_2_0 = (Keyword)cNEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNE2EnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNE2LessThanSignGreaterThanSignKeyword_3_0 = (Keyword)cNE2EnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGTGreaterThanSignKeyword_4_0 = (Keyword)cGTEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGEEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cLTLessThanSignKeyword_6_0 = (Keyword)cLTEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cLELessThanSignEqualsSignKeyword_7_0 = (Keyword)cLEEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cLIKEEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cLIKELikeKeyword_8_0 = (Keyword)cLIKEEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cLIKE2EnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cLIKE2TildeKeyword_9_0 = (Keyword)cLIKE2EnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cUNLIKEEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cUNLIKEUnlikeKeyword_10_0 = (Keyword)cUNLIKEEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cUNLIKE2EnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cUNLIKE2ExclamationMarkTildeKeyword_11_0 = (Keyword)cUNLIKE2EnumLiteralDeclaration_11.eContents().get(0);
		private final EnumLiteralDeclaration cSTARTSEnumLiteralDeclaration_12 = (EnumLiteralDeclaration)cAlternatives.eContents().get(12);
		private final Keyword cSTARTSStartsKeyword_12_0 = (Keyword)cSTARTSEnumLiteralDeclaration_12.eContents().get(0);
		private final EnumLiteralDeclaration cENDSEnumLiteralDeclaration_13 = (EnumLiteralDeclaration)cAlternatives.eContents().get(13);
		private final Keyword cENDSEndsKeyword_13_0 = (Keyword)cENDSEnumLiteralDeclaration_13.eContents().get(0);
		private final EnumLiteralDeclaration cCONTAINSEnumLiteralDeclaration_14 = (EnumLiteralDeclaration)cAlternatives.eContents().get(14);
		private final Keyword cCONTAINSContainsKeyword_14_0 = (Keyword)cCONTAINSEnumLiteralDeclaration_14.eContents().get(0);
		
		//enum StringOperator:
		//	EQ="=" | EQ2="==" | NE="!=" | NE2="<>" | GT=">" | GE=">=" | LT="<" | LE="<=" | LIKE="like" | LIKE2="~" |
		//	UNLIKE="unlike" | UNLIKE2="!~" | STARTS="starts" | ENDS="ends" | CONTAINS="contains";
		public EnumRule getRule() { return rule; }

		//EQ="=" | EQ2="==" | NE="!=" | NE2="<>" | GT=">" | GE=">=" | LT="<" | LE="<=" | LIKE="like" | LIKE2="~" | UNLIKE="unlike"
		//| UNLIKE2="!~" | STARTS="starts" | ENDS="ends" | CONTAINS="contains"
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQ="="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }

		//EQ2="=="
		public EnumLiteralDeclaration getEQ2EnumLiteralDeclaration_1() { return cEQ2EnumLiteralDeclaration_1; }

		//"=="
		public Keyword getEQ2EqualsSignEqualsSignKeyword_1_0() { return cEQ2EqualsSignEqualsSignKeyword_1_0; }

		//NE="!="
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_2() { return cNEEnumLiteralDeclaration_2; }

		//"!="
		public Keyword getNEExclamationMarkEqualsSignKeyword_2_0() { return cNEExclamationMarkEqualsSignKeyword_2_0; }

		//NE2="<>"
		public EnumLiteralDeclaration getNE2EnumLiteralDeclaration_3() { return cNE2EnumLiteralDeclaration_3; }

		//"<>"
		public Keyword getNE2LessThanSignGreaterThanSignKeyword_3_0() { return cNE2LessThanSignGreaterThanSignKeyword_3_0; }

		//GT=">"
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_4() { return cGTEnumLiteralDeclaration_4; }

		//">"
		public Keyword getGTGreaterThanSignKeyword_4_0() { return cGTGreaterThanSignKeyword_4_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_5() { return cGEEnumLiteralDeclaration_5; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_5_0() { return cGEGreaterThanSignEqualsSignKeyword_5_0; }

		//LT="<"
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_6() { return cLTEnumLiteralDeclaration_6; }

		//"<"
		public Keyword getLTLessThanSignKeyword_6_0() { return cLTLessThanSignKeyword_6_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_7() { return cLEEnumLiteralDeclaration_7; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_7_0() { return cLELessThanSignEqualsSignKeyword_7_0; }

		//LIKE="like"
		public EnumLiteralDeclaration getLIKEEnumLiteralDeclaration_8() { return cLIKEEnumLiteralDeclaration_8; }

		//"like"
		public Keyword getLIKELikeKeyword_8_0() { return cLIKELikeKeyword_8_0; }

		//LIKE2="~"
		public EnumLiteralDeclaration getLIKE2EnumLiteralDeclaration_9() { return cLIKE2EnumLiteralDeclaration_9; }

		//"~"
		public Keyword getLIKE2TildeKeyword_9_0() { return cLIKE2TildeKeyword_9_0; }

		//UNLIKE="unlike"
		public EnumLiteralDeclaration getUNLIKEEnumLiteralDeclaration_10() { return cUNLIKEEnumLiteralDeclaration_10; }

		//"unlike"
		public Keyword getUNLIKEUnlikeKeyword_10_0() { return cUNLIKEUnlikeKeyword_10_0; }

		//UNLIKE2="!~"
		public EnumLiteralDeclaration getUNLIKE2EnumLiteralDeclaration_11() { return cUNLIKE2EnumLiteralDeclaration_11; }

		//"!~"
		public Keyword getUNLIKE2ExclamationMarkTildeKeyword_11_0() { return cUNLIKE2ExclamationMarkTildeKeyword_11_0; }

		//STARTS="starts"
		public EnumLiteralDeclaration getSTARTSEnumLiteralDeclaration_12() { return cSTARTSEnumLiteralDeclaration_12; }

		//"starts"
		public Keyword getSTARTSStartsKeyword_12_0() { return cSTARTSStartsKeyword_12_0; }

		//ENDS="ends"
		public EnumLiteralDeclaration getENDSEnumLiteralDeclaration_13() { return cENDSEnumLiteralDeclaration_13; }

		//"ends"
		public Keyword getENDSEndsKeyword_13_0() { return cENDSEndsKeyword_13_0; }

		//CONTAINS="contains"
		public EnumLiteralDeclaration getCONTAINSEnumLiteralDeclaration_14() { return cCONTAINSEnumLiteralDeclaration_14; }

		//"contains"
		public Keyword getCONTAINSContainsKeyword_14_0() { return cCONTAINSContainsKeyword_14_0; }
	}

	public class TypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFILEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFILEFileKeyword_0_0 = (Keyword)cFILEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFOLDEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFOLDERFolderKeyword_1_0 = (Keyword)cFOLDEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCONTAINEREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCONTAINERContainerKeyword_2_0 = (Keyword)cCONTAINEREnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cPROJECTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cPROJECTProjectKeyword_3_0 = (Keyword)cPROJECTEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Type:
		//	FILE="file" | FOLDER="folder" | CONTAINER="container" | PROJECT="project";
		public EnumRule getRule() { return rule; }

		//FILE="file" | FOLDER="folder" | CONTAINER="container" | PROJECT="project"
		public Alternatives getAlternatives() { return cAlternatives; }

		//FILE="file"
		public EnumLiteralDeclaration getFILEEnumLiteralDeclaration_0() { return cFILEEnumLiteralDeclaration_0; }

		//"file"
		public Keyword getFILEFileKeyword_0_0() { return cFILEFileKeyword_0_0; }

		//FOLDER="folder"
		public EnumLiteralDeclaration getFOLDEREnumLiteralDeclaration_1() { return cFOLDEREnumLiteralDeclaration_1; }

		//"folder"
		public Keyword getFOLDERFolderKeyword_1_0() { return cFOLDERFolderKeyword_1_0; }

		//CONTAINER="container"
		public EnumLiteralDeclaration getCONTAINEREnumLiteralDeclaration_2() { return cCONTAINEREnumLiteralDeclaration_2; }

		//"container"
		public Keyword getCONTAINERContainerKeyword_2_0() { return cCONTAINERContainerKeyword_2_0; }

		//PROJECT="project"
		public EnumLiteralDeclaration getPROJECTEnumLiteralDeclaration_3() { return cPROJECTEnumLiteralDeclaration_3; }

		//"project"
		public Keyword getPROJECTProjectKeyword_3_0() { return cPROJECTProjectKeyword_3_0; }
	}

	public class KindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "Kind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cREFERENCEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cREFERENCEReferenceKeyword_0_0 = (Keyword)cREFERENCEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNATUREEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNATURENatureKeyword_1_0 = (Keyword)cNATUREEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cBUILDEREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cBUILDERBuilderKeyword_2_0 = (Keyword)cBUILDEREnumLiteralDeclaration_2.eContents().get(0);
		
		//enum Kind:
		//	REFERENCE="reference" | NATURE="nature" | BUILDER="builder";
		public EnumRule getRule() { return rule; }

		//REFERENCE="reference" | NATURE="nature" | BUILDER="builder"
		public Alternatives getAlternatives() { return cAlternatives; }

		//REFERENCE="reference"
		public EnumLiteralDeclaration getREFERENCEEnumLiteralDeclaration_0() { return cREFERENCEEnumLiteralDeclaration_0; }

		//"reference"
		public Keyword getREFERENCEReferenceKeyword_0_0() { return cREFERENCEReferenceKeyword_0_0; }

		//NATURE="nature"
		public EnumLiteralDeclaration getNATUREEnumLiteralDeclaration_1() { return cNATUREEnumLiteralDeclaration_1; }

		//"nature"
		public Keyword getNATURENatureKeyword_1_0() { return cNATURENatureKeyword_1_0; }

		//BUILDER="builder"
		public EnumLiteralDeclaration getBUILDEREnumLiteralDeclaration_2() { return cBUILDEREnumLiteralDeclaration_2; }

		//"builder"
		public Keyword getBUILDERBuilderKeyword_2_0() { return cBUILDERBuilderKeyword_2_0; }
	}
	
	private BooleanExpressionElements pBooleanExpression;
	private OrExpressionElements pOrExpression;
	private XorExpressionElements pXorExpression;
	private AndExpressionElements pAndExpression;
	private ComparisonExpressionElements pComparisonExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private BooleanLiteralElements pBooleanLiteral;
	private NotExpressionElements pNotExpression;
	private IsExpressionElements pIsExpression;
	private HasExpressionElements pHasExpression;
	private TestExpressionElements pTestExpression;
	private ConcatExpressionElements pConcatExpression;
	private StringExpressionElements pStringExpression;
	private StringLiteralElements pStringLiteral;
	private PropertyAccessElements pPropertyAccess;
	private OrOperatorElements pOrOperator;
	private XorOperatorElements pXorOperator;
	private AndOperatorElements pAndOperator;
	private NotOperatorElements pNotOperator;
	private ComparisonOperatorElements unknownRuleComparisonOperator;
	private StringOperatorElements unknownRuleStringOperator;
	private TypeElements unknownRuleType;
	private KindElements unknownRuleKind;
	private TerminalRule tBOOLEAN;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public DslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//BooleanExpression:
	//	OrExpression;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return (pBooleanExpression != null) ? pBooleanExpression : (pBooleanExpression = new BooleanExpressionElements());
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}

	//OrExpression returns BooleanExpression:
	//	XorExpression ({OrExpression.left=current} OrOperator right=XorExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//XorExpression returns BooleanExpression:
	//	AndExpression ({XorExpression.left=current} XorOperator right=AndExpression)*;
	public XorExpressionElements getXorExpressionAccess() {
		return (pXorExpression != null) ? pXorExpression : (pXorExpression = new XorExpressionElements());
	}
	
	public ParserRule getXorExpressionRule() {
		return getXorExpressionAccess().getRule();
	}

	//AndExpression returns BooleanExpression:
	//	ComparisonExpression ({AndExpression.left=current} AndOperator right=ComparisonExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//ComparisonExpression returns BooleanExpression:
	//	PrimaryExpression ({BooleanComparison.left=current} operator=ComparisonOperator right=PrimaryExpression)* |
	//	ConcatExpression ({StringComparison.left=current} operator=StringOperator right=ConcatExpression)+;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//PrimaryExpression returns BooleanExpression:
	//	BooleanLiteral | NotExpression | IsExpression | HasExpression | TestExpression | "(" OrExpression ")";
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//BooleanLiteral:
	//	value=BOOLEAN;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//NotExpression returns BooleanExpression:
	//	{NotExpression} NotOperator right=PrimaryExpression;
	public NotExpressionElements getNotExpressionAccess() {
		return (pNotExpression != null) ? pNotExpression : (pNotExpression = new NotExpressionElements());
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//IsExpression returns BooleanExpression:
	//	{IsExpression} "is" type=Type;
	public IsExpressionElements getIsExpressionAccess() {
		return (pIsExpression != null) ? pIsExpression : (pIsExpression = new IsExpressionElements());
	}
	
	public ParserRule getIsExpressionRule() {
		return getIsExpressionAccess().getRule();
	}

	//HasExpression returns BooleanExpression:
	//	{HasExpression} "has" kind=Kind what=ConcatExpression;
	public HasExpressionElements getHasExpressionAccess() {
		return (pHasExpression != null) ? pHasExpression : (pHasExpression = new HasExpressionElements());
	}
	
	public ParserRule getHasExpressionRule() {
		return getHasExpressionAccess().getRule();
	}

	//TestExpression returns BooleanExpression:
	//	{TestExpression} property+=ID ("." property+=ID)* "(" args+=ConcatExpression ("," args+=ConcatExpression)* ")" "is"
	//	expected=ConcatExpression;
	public TestExpressionElements getTestExpressionAccess() {
		return (pTestExpression != null) ? pTestExpression : (pTestExpression = new TestExpressionElements());
	}
	
	public ParserRule getTestExpressionRule() {
		return getTestExpressionAccess().getRule();
	}

	//ConcatExpression returns StringExpression:
	//	StringExpression ({ConcatExpression.left=current} "+" right=StringExpression)*;
	public ConcatExpressionElements getConcatExpressionAccess() {
		return (pConcatExpression != null) ? pConcatExpression : (pConcatExpression = new ConcatExpressionElements());
	}
	
	public ParserRule getConcatExpressionRule() {
		return getConcatExpressionAccess().getRule();
	}

	//StringExpression:
	//	StringLiteral | PropertyAccess;
	public StringExpressionElements getStringExpressionAccess() {
		return (pStringExpression != null) ? pStringExpression : (pStringExpression = new StringExpressionElements());
	}
	
	public ParserRule getStringExpressionRule() {
		return getStringExpressionAccess().getRule();
	}

	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//PropertyAccess:
	//	property=ID;
	public PropertyAccessElements getPropertyAccessAccess() {
		return (pPropertyAccess != null) ? pPropertyAccess : (pPropertyAccess = new PropertyAccessElements());
	}
	
	public ParserRule getPropertyAccessRule() {
		return getPropertyAccessAccess().getRule();
	}

	//OrOperator returns ecore::EString:
	//	"|" | "||" | "or";
	public OrOperatorElements getOrOperatorAccess() {
		return (pOrOperator != null) ? pOrOperator : (pOrOperator = new OrOperatorElements());
	}
	
	public ParserRule getOrOperatorRule() {
		return getOrOperatorAccess().getRule();
	}

	//XorOperator returns ecore::EString:
	//	"^" | "xor";
	public XorOperatorElements getXorOperatorAccess() {
		return (pXorOperator != null) ? pXorOperator : (pXorOperator = new XorOperatorElements());
	}
	
	public ParserRule getXorOperatorRule() {
		return getXorOperatorAccess().getRule();
	}

	//AndOperator returns ecore::EString:
	//	"&" | "&&" | "and";
	public AndOperatorElements getAndOperatorAccess() {
		return (pAndOperator != null) ? pAndOperator : (pAndOperator = new AndOperatorElements());
	}
	
	public ParserRule getAndOperatorRule() {
		return getAndOperatorAccess().getRule();
	}

	//NotOperator returns ecore::EString:
	//	"!" | "not";
	public NotOperatorElements getNotOperatorAccess() {
		return (pNotOperator != null) ? pNotOperator : (pNotOperator = new NotOperatorElements());
	}
	
	public ParserRule getNotOperatorRule() {
		return getNotOperatorAccess().getRule();
	}

	//enum ComparisonOperator:
	//	EQ="=" | EQ2="==" | NE="!=" | NE2="<>" | GT=">" | GE=">=" | LT="<" | LE="<=";
	public ComparisonOperatorElements getComparisonOperatorAccess() {
		return (unknownRuleComparisonOperator != null) ? unknownRuleComparisonOperator : (unknownRuleComparisonOperator = new ComparisonOperatorElements());
	}
	
	public EnumRule getComparisonOperatorRule() {
		return getComparisonOperatorAccess().getRule();
	}

	//enum StringOperator:
	//	EQ="=" | EQ2="==" | NE="!=" | NE2="<>" | GT=">" | GE=">=" | LT="<" | LE="<=" | LIKE="like" | LIKE2="~" |
	//	UNLIKE="unlike" | UNLIKE2="!~" | STARTS="starts" | ENDS="ends" | CONTAINS="contains";
	public StringOperatorElements getStringOperatorAccess() {
		return (unknownRuleStringOperator != null) ? unknownRuleStringOperator : (unknownRuleStringOperator = new StringOperatorElements());
	}
	
	public EnumRule getStringOperatorRule() {
		return getStringOperatorAccess().getRule();
	}

	//enum Type:
	//	FILE="file" | FOLDER="folder" | CONTAINER="container" | PROJECT="project";
	public TypeElements getTypeAccess() {
		return (unknownRuleType != null) ? unknownRuleType : (unknownRuleType = new TypeElements());
	}
	
	public EnumRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//enum Kind:
	//	REFERENCE="reference" | NATURE="nature" | BUILDER="builder";
	public KindElements getKindAccess() {
		return (unknownRuleKind != null) ? unknownRuleKind : (unknownRuleKind = new KindElements());
	}
	
	public EnumRule getKindRule() {
		return getKindAccess().getRule();
	}

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"false" | "true";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" | "n" |
	//	"f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
